# src/feature_engineer.py
import pandas as pd
import numpy as np

class FeatureEngineer:
    def __init__(self, df: pd.DataFrame):
        """
        Initialize FeatureEngineer with a DataFrame containing preprocessed data.
        
        :param df: DataFrame with preprocessed data. It should have a datetime index and a 'Close' column.
        """
        self.df = df.copy()

    def add_sma(self, window: int = 10, column: str = "Close") -> pd.DataFrame:
        """
        Calculate Simple Moving Average (SMA) and add it as a new column.
        
        :param window: Window period for SMA.
        :param column: Column to calculate SMA on.
        :return: DataFrame with SMA column added.
        """
        self.df[f"SMA_{window}"] = self.df[column].rolling(window=window).mean()
        return self.df
    
    def add_ema(self, span: int = 10, column: str = "Close") -> pd.DataFrame:
        """
        Calculate Exponential Moving Average (EMA) and add it as a new column.
        
        :param span: Span for EMA.
        :param column: Column to calculate EMA on.
        :return: DataFrame with EMA column added.
        """
        self.df[f"EMA_{span}"] = self.df[column].ewm(span=span, adjust=False).mean()
        return self.df

    def add_rsi(self, period: int = 14, column: str = "Close") -> pd.DataFrame:
        """
        Calculate Relative Strength Index (RSI) and add it as a new column.
        
        :param period: Number of periods to calculate RSI.
        :param column: Column to calculate RSI on.
        :return: DataFrame with RSI column added.
        """
        # Calculate price differences
        delta = self.df[column].diff()
        # Separate gains and losses
        gain = delta.where(delta > 0, 0)
        loss = -delta.where(delta < 0, 0)
        
        # Calculate rolling average of gains and losses
        avg_gain = gain.rolling(window=period).mean()
        avg_loss = loss.rolling(window=period).mean()
        
        # Calculate Relative Strength (RS)
        rs = avg_gain / avg_loss
        # Calculate RSI based on RS
        self.df[f"RSI_{period}"] = 100 - (100 / (1 + rs))
        return self.df
    
    def add_macd(self, column: str = "Close", span_short: int = 12, span_long: int = 26, span_signal: int = 9) -> pd.DataFrame:
        """
        Calculate MACD and add MACD line and signal line as new columns.
        
        :param column: Column to calculate MACD on.
        :param span_short: Span for the short EMA.
        :param span_long: Span for the long EMA.
        :param span_signal: Span for the signal line.
        :return: DataFrame with MACD and Signal columns added.
        """
        ema_short = self.df[column].ewm(span=span_short, adjust=False).mean()
        ema_long = self.df[column].ewm(span=span_long, adjust=False).mean()
        macd = ema_short - ema_long
        signal = macd.ewm(span=span_signal, adjust=False).mean()
        self.df["MACD"] = macd
        self.df["MACD_Signal"] = signal
        return self.df
    
    def add_lag_features(self, column: str = "Close", lags: list = [1, 2, 3]) -> pd.DataFrame:
        """
        Create lag features for a given column.
        
        :param column: Column to create lag features for.
        :param lags: List of lag periods.
        :return: DataFrame with lag features added.
        """
        for lag in lags:
            self.df[f"{column}_lag_{lag}"] = self.df[column].shift(lag)
        return self.df

    def engineer_features(self) -> pd.DataFrame:
        """
        Compute all technical indicators and lag features.
        
        :return: DataFrame with all new features added.
        """
        # Add SMA features with different window sizes
        self.add_sma(window=10)
        self.add_sma(window=20)
        # Add EMA features with different spans
        self.add_ema(span=10)
        self.add_ema(span=20)
        # Add RSI
        self.add_rsi(period=14)
        # Add MACD and its signal line
        self.add_macd()
        # Add lag features for the 'Close' price
        self.add_lag_features(column="Close", lags=[1, 2, 3])
        # Drop rows with NaN values generated by rolling calculations
        self.df.dropna(inplace=True)
        return self.df

if __name__ == "__main__":
    # Sample test: Using DataLoader and DataPreprocessor to obtain preprocessed data
    from data_loader import DataLoader
    from data_preprocessor import DataPreprocessor
    
    # Fetch data using yfinance
    loader = DataLoader(symbol="^GDAXI", interval="5m", period="60d")
    raw_data = loader.fetch_data()
    
    # Preprocess the data: clean, format datetime and sort the data
    preprocessor = DataPreprocessor(raw_data)
    preprocessed_data = preprocessor.clean_data()
    preprocessed_data = preprocessor.format_datetime(datetime_col="Datetime", new_index=True)
    preprocessed_data = preprocessor.sort_data()
    
    # Perform feature engineering
    fe = FeatureEngineer(preprocessed_data)
    df_features = fe.engineer_features()
    
    # Print the resulting DataFrame with engineered features
    print("Feature Engineered Data:")
    print(df_features.head())